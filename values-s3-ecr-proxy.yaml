# Default values for docker-registry.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
replicaCount: 1

updateStrategy: {}
  # type: RollingUpdate
  # rollingUpdate:
  #   maxSurge: 1
  #   maxUnavailable: 0

podAnnotations: {}
podLabels: {}

serviceAccount:
  create: true
  name: "docker-registry-sa"
  annotations:
    eks.amazonaws.com/role-arn: "arn:aws:iam::281387974444:role/DockerRegistryS3Role"

image:
  repository: denstorti/docker-registry-ecr # MODIFIED to registry-ecr-image from registry
  tag: latest
  pullPolicy: IfNotPresent
# imagePullSecrets:
    # - name: docker
deployment: {}
  # annotations:
service:
  name: registry
  type: NodePort # MODIFIED to NodePort from ClusterIP
  # sessionAffinity: None
  # sessionAffinityConfig: {}
  # clusterIP:
  port: 5000
  nodePort: 30008 # MODIFIED to enable
  # loadBalancerIP:
  # loadBalancerSourceRanges:
  annotations: {}
  # foo.io/bar: "true"
  labels: {}
  # foo.io/baz: "false"
ingress:
  enabled: false
  className: nginx
  path: /
  # Used to create an Ingress record.
  hosts:
    - chart-example.local
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  labels: {}
  tls:
    # Secrets must be manually created in the namespace.
    # - secretName: chart-example-tls
    #   hosts:
    #     - chart-example.local
resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi
persistence:
  accessMode: 'ReadWriteOnce'
  enabled: false
  size: 10Gi
  # storageClass: '-'

# set the type of filesystem to use: filesystem, s3
storage: s3 # MODIFIED to s3 from filesystem

# Set this to name of secret for tls certs
# tlsSecretName: 
secrets:
  haSharedSecret: ""
  htpasswd: ""
# Secrets for Azure
#   azure:
#     accountName: ""
#     accountKey: ""
#     container: ""
# Secrets for S3 access and secret keys
# When using IRSA, leave these empty as AWS credentials are provided automatically
  s3:
    secretRef: ""
    accessKey: ""
    secretKey: ""
# Secrets for Swift username and password
#   swift:
#     username: ""
#     password: ""

# Options for s3 storage type:  # MODIFIED
s3:
  region: us-east-1
  regionEndpoint: https://s3.us-east-1.amazonaws.com
  bucket: registry-denisstorti
  rootdirectory: /
  encrypt: false
  secure: true
  forcepathstyle: true
  skipverify: true

# Options for swift storage type:
# swift:
#   authurl: http://swift.example.com/
#   container: my-container

# https://docs.docker.com/registry/recipes/mirror/
proxy:
  enabled: false # MODIFIED to true
  # remoteurl: https://quay.io
  remoteurl: https://281387974444.dkr.ecr.us-east-1.amazonaws.com
  username: "" 
  password: ""
  # the ref for a secret stored outside of this chart
  # Keys: proxyUsername, proxyPassword
  secretRef: ""

metrics:
  enabled: false
  port: 5001
  # Create a prometheus-operator servicemonitor
  serviceMonitor:
    enabled: false
    labels: {}
  # prometheus-operator PrometheusRule defining alerting rules for a Prometheus instance
  prometheusRule:
    enabled: false
    labels: {}
    rules: {}

configPath: /etc/distribution
configData:
  version: 0.1
  log:
    level: debug
    fields:
      service: registry
  storage:
    cache:
      blobdescriptor: inmemory
  http:
    addr: :5000
    headers:
      X-Content-Type-Options: [nosniff]
    debug:
      addr: :5001
      prometheus:
        enabled: false
        path: /metrics
  health:
    storagedriver:
      enabled: true
      interval: 10s
      threshold: 3
  proxy:
    remoteurl: https://281387974444.dkr.ecr.us-east-1.amazonaws.com
    # username: "AWS" 
    # password: ""
    exec: 
      command: /usr/bin/docker-credential-ecr-login
      lifetime: 12h 

containerSecurityContext:
  enabled: true
  seLinuxOptions: {}
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  privileged: false
  readOnlyRootFilesystem: true
  runAsUser: 1000
  runAsGroup: 1000
  runAsNonRoot: true
  seccompProfile:
    type: RuntimeDefault

securityContext:
  enabled: true
  fsGroupChangePolicy: Always
  sysctls: []
  supplementalGroups: []
  runAsUser: 1000
  fsGroup: 1000

priorityClassName: ""

podDisruptionBudget: {}
  # maxUnavailable: 1
  # minAvailable: 2

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 2
  targetCPUUtilizationPercentage: 60
  targetMemoryUtilizationPercentage: 60 # available only on Kubernetes ≥1.23 [required "autoscaling/v2"]
  behavior: {} # available only on Kubernetes ≥1.23 [required "autoscaling/v2"]
#   scaleDown:
#     stabilizationWindowSeconds: 300
#     policies:
#     - type: Percent
#       value: 100
#       periodSeconds: 15
#   scaleUp:
#     stabilizationWindowSeconds: 0
#     policies:
#     - type: Percent
#       value: 100
#       periodSeconds: 15
#     - type: Pods
#       value: 4
#       periodSeconds: 15
#     selectPolicy: Max

nodeSelector: {}

affinity: {}

tolerations: []

extraVolumeMounts: # MODIFIED
  - mountPath: /.aws
    name: aws-credentials
    readOnly: true
  - mountPath: /.docker
    name: docker-config
    readOnly: true

extraVolumes: # MODIFIED
  - emptyDir: {}
    name: aws-credentials
  - emptyDir: {}
    name: docker-config

## Additional volumes to the pod.
#  - name: cloudfront-pem-secret
#    secret:
#      secretName: cloudfront-credentials
#      items:
#        - key: cloudfront.pem
#          path: cloudfront.pem
#          mode: 511

extraEnvVars: # MODIFIED
## Additional ENV variables to set
- name: AWS_WEB_IDENTITY_TOKEN_FILE # Supress Web Identity credentials to prioritize /.aws/credentials
  value: ""
- name: AWS_ROLE_ARN
  value: ""
- name: OTEL_TRACES_EXPORTER  # Disable tracer, DEV ONLY
  value: "none"
- name: AWS_SHARED_CREDENTIALS_FILE 
  value: "/.aws/credentials"
# - name: DOCKER_CONFIG # non-default location for Docker config. Don't append config.json.
#   value: "/.aws"

initContainers:
## Init containers to add to the Deployment
- name: credential-refresher-sidecar
  image: public.ecr.aws/aws-cli/aws-cli:latest
  command:
    - /bin/sh
    - -c
    - |
      set -e

      # Function to get credentials
      get_credentials() {
        echo "Getting AWS credentials..."
        echo WHOAMI: $(whoami)
        echo AWS_ROLE_ARN: $AWS_ROLE_ARN
        CREDS=$(aws sts assume-role --role-arn $AWS_ROLE_ARN --role-session-name registry-proxy-session --duration-seconds 3600 --output text)
        ACCESS_KEY=$(echo "$CREDS" | grep CREDENTIALS | cut -f2)
        SECRET_KEY=$(echo "$CREDS" | grep CREDENTIALS | cut -f4)
        SESSION_TOKEN=$(echo "$CREDS" | grep CREDENTIALS | cut -f5)

        cat > /root/.aws/credentials << EOF
      [default]
      aws_access_key_id = $ACCESS_KEY
      aws_secret_access_key = $SECRET_KEY
      aws_session_token = $SESSION_TOKEN
      EOF

        echo "Credentials updated at $(date)"
      }

      get_ecr_credentials() {
        echo "Getting ECR credentials..."
        ECR_TOKEN=$(aws ecr get-login-password --region us-east-1)
        echo $ECR_TOKEN > /root/.aws/ecr-token.txt
        cat /root/.aws/ecr-token.txt # DEBUG ONLY
        echo "ECR credentials updated at $(date)"
      }

      write_ecr_docker_config() {
        local config_path="${1:-/root/.docker/config.json}"  # Docker config in non-default location
        mkdir -p "$(dirname "$config_path")"
        # Infer AWS region
        local region="${AWS_REGION:-us-east-1}"
        # Extract AWS account ID from AWS_ROLE_ARN (arn:aws:iam::<account-id>:role/...)
        if [[ -n "${AWS_ROLE_ARN:-}" ]]; then
          local aws_account_id
          aws_account_id=$(echo "$AWS_ROLE_ARN" | cut -d: -f5)
        else
          echo "❌ AWS_ROLE_ARN not set" >&2
          return 1
        fi
        # Construct registry URL
        local ecr_registry="${aws_account_id}.dkr.ecr.${region}.amazonaws.com"
        # Get password from AWS CLI
        local password
        password=$(aws ecr get-login-password --region "$region")
        # Build base64-encoded auth (AWS:<password>)
        local auth
        auth=$(echo -n "AWS:${password}" | base64 | tr -d '\n')
        cat > "$config_path" <<EOF
      {
        "auths": {
          "${ecr_registry}": {
            "auth": "${auth}"
          }
        }
      }
      EOF
        echo "✅ Wrote Docker config for ECR registry: $ecr_registry"
        cat "$config_path" 
        echo "📄 Location: $config_path"
      }

      get_credentials
      get_ecr_credentials
      write_ecr_docker_config

      while true; do
        sleep 15  # 15 seconds for DEBUG, ideally 30~45 minutes (less than 1 hour)
        get_credentials
        get_ecr_credentials
        write_ecr_docker_config
      done &

      # Keep container running
      tail -f /dev/null
  restartPolicy: Always
  securityContext:
    runAsUser: 0
  env:
    - name: AWS_REGION
      value: us-east-1
  volumeMounts:
    - mountPath: /root/.aws
      name: aws-credentials
    - mountPath: /root/.docker
      name: docker-config

garbageCollect:
  enabled: false
  deleteUntagged: true
  schedule: "0 1 * * *"
  podAnnotations: {}
  podLabels: {}
  resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi
