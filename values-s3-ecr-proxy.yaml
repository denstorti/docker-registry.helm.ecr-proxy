# Default values for docker-registry.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
replicaCount: 1

updateStrategy: {}
  # type: RollingUpdate
  # rollingUpdate:
  #   maxSurge: 1
  #   maxUnavailable: 0

podAnnotations: {}
podLabels: {}

serviceAccount: # MODIFIED to enable IRSA
  create: true
  name: "docker-registry-sa"
  annotations:
    eks.amazonaws.com/role-arn: "arn:aws:iam::281387974444:role/DockerRegistryRole" 

image:
  repository: denstorti/docker-registry-ecr # MODIFIED to registry-ecr-image from registry
  tag: latest
  pullPolicy: Always
# imagePullSecrets:
    # - name: docker
deployment: {}
  # annotations:
service:
  name: registry
  type: NodePort # MODIFIED to NodePort from ClusterIP
  # sessionAffinity: None
  # sessionAffinityConfig: {}
  # clusterIP:
  port: 5000
  nodePort: 30008 # MODIFIED to set node port
  # loadBalancerIP:
  # loadBalancerSourceRanges:
  annotations: {}
  # foo.io/bar: "true"
  labels: {}
  # foo.io/baz: "false"
ingress:
  enabled: false
  className: nginx
  path: /
  # Used to create an Ingress record.
  hosts:
    - chart-example.local
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  labels: {}
  tls:
    # Secrets must be manually created in the namespace.
    # - secretName: chart-example-tls
    #   hosts:
    #     - chart-example.local
resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi
persistence:
  accessMode: 'ReadWriteOnce'
  enabled: false
  size: 10Gi
  # storageClass: '-'

# set the type of filesystem to use: filesystem, s3
storage: s3 # MODIFIED to s3 from filesystem

# Set this to name of secret for tls certs
# tlsSecretName: 
secrets:
  haSharedSecret: ""
  htpasswd: ""
# Secrets for Azure
#   azure:
#     accountName: ""
#     accountKey: ""
#     container: ""
# Secrets for S3 access and secret keys
# When using IRSA, leave these empty as AWS credentials are provided automatically
  s3:
    secretRef: ""
    accessKey: ""
    secretKey: ""
# Secrets for Swift username and password
#   swift:
#     username: ""
#     password: ""

# Options for s3 storage type
s3: # MODIFIED to use S3 as storage type
  region: us-east-1
  regionEndpoint: https://s3.us-east-1.amazonaws.com
  bucket: registry-denisstorti
  rootdirectory: /
  encrypt: false
  secure: true
  forcepathstyle: true
  skipverify: true

# Options for swift storage type:
# swift:
#   authurl: http://swift.example.com/
#   container: my-container

# https://docs.docker.com/registry/recipes/mirror/
# proxy:
#   enabled: false 
#   # remoteurl: https://quay.io
#   remoteurl: https://281387974444.dkr.ecr.us-east-1.amazonaws.com
#   username: "" 
#   password: ""
#   # the ref for a secret stored outside of this chart
#   # Keys: proxyUsername, proxyPassword
#   secretRef: ""

metrics:
  enabled: false
  port: 5001
  # Create a prometheus-operator servicemonitor
  serviceMonitor:
    enabled: false
    labels: {}
  # prometheus-operator PrometheusRule defining alerting rules for a Prometheus instance
  prometheusRule:
    enabled: false
    labels: {}
    rules: {}

configPath: /etc/distribution
configData:
  version: 0.1
  log:
    level: debug # MODIFIED to use debug level
    formatter: json # MODIFIED to use json formatter
    fields:
      service: registry
  storage:
    cache:
      blobdescriptor: inmemory
  http:
    addr: :5000
    headers:
      X-Content-Type-Options: [nosniff]
    debug:
      addr: :5001
      prometheus:
        enabled: false
        path: /metrics
  health:
    storagedriver:
      enabled: true
      interval: 10s
      threshold: 3
  delete:
    enabled: true
  proxy:  # MODIFIED to use the custom image with the docker-credential-ecr-login helper
    remoteurl: https://281387974444.dkr.ecr.us-east-1.amazonaws.com
    ttl: 1m # MODIFIED to 1 minute TTL
    exec: 
      command: /usr/bin/docker-credential-ecr-login
      lifetime: 12h 

containerSecurityContext:
  enabled: true
  seLinuxOptions: {}
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  privileged: false
  readOnlyRootFilesystem: true
  runAsUser: 1000
  runAsGroup: 1000
  runAsNonRoot: true
  seccompProfile:
    type: RuntimeDefault

securityContext:
  enabled: true
  fsGroupChangePolicy: Always
  sysctls: []
  supplementalGroups: []
  runAsUser: 1000
  fsGroup: 1000

priorityClassName: ""

podDisruptionBudget: {}
  # maxUnavailable: 1
  # minAvailable: 2

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 2
  targetCPUUtilizationPercentage: 60
  targetMemoryUtilizationPercentage: 60 # available only on Kubernetes ≥1.23 [required "autoscaling/v2"]
  behavior: {} # available only on Kubernetes ≥1.23 [required "autoscaling/v2"]
#   scaleDown:
#     stabilizationWindowSeconds: 300
#     policies:
#     - type: Percent
#       value: 100
#       periodSeconds: 15
#   scaleUp:
#     stabilizationWindowSeconds: 0
#     policies:
#     - type: Percent
#       value: 100
#       periodSeconds: 15
#     - type: Pods
#       value: 4
#       periodSeconds: 15
#     selectPolicy: Max

nodeSelector: {}

affinity: {}

tolerations: []

extraVolumeMounts: # MODIFIED to add volume mounts for AWS credentials
  - mountPath: /.aws
    name: aws-credentials
    readOnly: true
  - mountPath: /.ecr
    name: ecr-cache

extraVolumes: # MODIFIED
  - emptyDir: {}
    name: aws-credentials
  - emptyDir: {}
    name: ecr-cache

## Additional volumes to the pod.
#  - name: cloudfront-pem-secret
#    secret:
#      secretName: cloudfront-credentials
#      items:
#        - key: cloudfront.pem
#          path: cloudfront.pem
#          mode: 511

extraEnvVars: # MODIFIED
## Additional ENV variables to set
- name: AWS_WEB_IDENTITY_TOKEN_FILE # Supress Web Identity credentials to prioritize /.aws/credentials. Bug in registry doesn't assume the role properly.
  value: ""
- name: AWS_ROLE_ARN
  value: ""
- name: AWS_SHARED_CREDENTIALS_FILE 
  value: "/.aws/credentials"
- name: REGISTRY_STORAGE_DELETE_ENABLED
  value: "true"

initContainers: # MODIFIED: this is where the magic happens for AWS credentials.
## Init containers to add to the Deployment
- name: credential-refresher-sidecar
  image: public.ecr.aws/aws-cli/aws-cli:latest
  command:
    - /bin/sh
    - -c
    - |
      set -e

      # Function to get credentials
      get_credentials() {
        echo "Getting AWS credentials..."
        echo WHOAMI: $(whoami)
        echo AWS_ROLE_ARN: $AWS_ROLE_ARN
        CREDS=$(aws sts assume-role --role-arn $AWS_ROLE_ARN --role-session-name registry-proxy-session --duration-seconds 3600 --output text)
        ACCESS_KEY=$(echo "$CREDS" | grep CREDENTIALS | cut -f2)
        SECRET_KEY=$(echo "$CREDS" | grep CREDENTIALS | cut -f4)
        SESSION_TOKEN=$(echo "$CREDS" | grep CREDENTIALS | cut -f5)

        cat > /root/.aws/credentials << EOF
      [default]
      aws_access_key_id = $ACCESS_KEY
      aws_secret_access_key = $SECRET_KEY
      aws_session_token = $SESSION_TOKEN
      EOF

        echo "Credentials updated at $(date)"
      }

      get_credentials

      while true; do
        sleep 1800  # 30 minutes for DEBUG, ideally 30~45 minutes (less than 1 hour)
        get_credentials
      done &

      # Keep container running
      tail -f /dev/null
  restartPolicy: Always
  securityContext:
    runAsUser: 0
  env:
    - name: AWS_REGION
      value: us-east-1
  volumeMounts:
    - mountPath: /root/.aws
      name: aws-credentials

garbageCollect:
  enabled: true
  deleteUntagged: true
  schedule: "* * * * *"
  podAnnotations: {}
  podLabels: {}
  resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

  initContainers: # MODIFIED: this is where the magic happens for AWS credentials.
  ## Init containers to add to the Deployment
  - name: credential-refresher-sidecar
    image: public.ecr.aws/aws-cli/aws-cli:latest
    command:
      - /bin/sh
      - -c
      - |
        set -e
    image: public.ecr.aws/aws-cli/aws-cli:latest
    command:
      - /bin/sh
      - -c
      - |
        set -e

        # Function to get credentials
        get_credentials() {
          echo "Getting AWS credentials..."
          echo WHOAMI: $(whoami)
          echo AWS_ROLE_ARN: $AWS_ROLE_ARN
          CREDS=$(aws sts assume-role --role-arn $AWS_ROLE_ARN --role-session-name registry-proxy-session --duration-seconds 3600 --output text)
          ACCESS_KEY=$(echo "$CREDS" | grep CREDENTIALS | cut -f2)
          SECRET_KEY=$(echo "$CREDS" | grep CREDENTIALS | cut -f4)
          SESSION_TOKEN=$(echo "$CREDS" | grep CREDENTIALS | cut -f5)

          cat > /root/.aws/credentials << EOF
        [default]
        aws_access_key_id = $ACCESS_KEY
        aws_secret_access_key = $SECRET_KEY
        aws_session_token = $SESSION_TOKEN
        EOF

          echo "Credentials updated at $(date)"
        }

        get_credentials

    # restartPolicy: Never  # DON'T RESTART FOR GARBAGE COLLECTOR
    securityContext:
      runAsUser: 0
    env:
      - name: AWS_REGION
        value: us-east-1
    volumeMounts:
      - mountPath: /root/.aws
        name: aws-credentials